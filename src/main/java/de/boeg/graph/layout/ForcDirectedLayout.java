package de.boeg.graph.layout;

import de.boeg.graph.layout.domain.Edge;
import de.boeg.graph.layout.domain.Node;

import java.util.*;

/**
 * Does the main magic for the force directed graph layout
 * derived from https://github.com/chaangliu/ForceDirectedLayout/blob/master/java/CollisionGenerator.java
 */
class ForceDirectedLayout<T> implements GraphLayout<T> {
    private final List<Node<T>> mNodeList;
    private final List<Edge<T>> mEdgeList;
    private final Map<String, Double> mDxMap = new HashMap<String, Double>();
    private final Map<String, Double> mDyMap = new HashMap<String, Double>();
    private final Map<String, Node<T>> mNodeMap;
    private final double k;

    private final int canvasHeight;
    private final int canvasWidth;
    private final int defaultEjectFactor;
    private final int defaultSmallDistEjectFactor;
    private final int defaultCondenseFactor;
    private final int maxt;
    private final int maxty;


    ForceDirectedLayout(List<Node<T>> nodeList, List<Edge<T>> edgeList, int height, int width, int defaultEjectFactor, int defaultSmallDistEjectFactor, int defaultCondenseFactor, int maxDeltaX, int maxDeltaY) {
        this.mNodeList = nodeList;
        this.mEdgeList = edgeList;

        canvasHeight = height;
        canvasWidth = width;
        this.defaultEjectFactor = defaultEjectFactor; // 6
        this.defaultSmallDistEjectFactor = defaultSmallDistEjectFactor; // 5
        this.defaultCondenseFactor = defaultCondenseFactor; // 3
        maxt = maxDeltaX; // 4
        maxty = maxDeltaY; // 3

        allNodesToCenter();

        k = Math.sqrt(canvasHeight * canvasWidth / (double) mNodeList.size());

        mNodeMap = new HashMap<>(nodeList.size());
        for(Node n : nodeList) {
            mNodeMap.put(n.getIdentifier().toString(), n);
        }
    }

    private void allNodesToCenter(){
        Random random = new Random(System.currentTimeMillis());
        for(Node node : mNodeList) {
            node.setX(random.nextDouble() * canvasWidth);
            node.setY(random.nextDouble() * canvasHeight);
        }
    }

    @Override
    public void layout() {
        calculateRepulsive();
        calculateTraction();
        updateCoordinates();
    }

    @Override
    public Collection<Node<T>> getNodes() {
        return this.mNodeList;
    }

    /**
     * Calculate the displacement generated by the repulsive force between two nodes.*
     */
    private void calculateRepulsive() {
        // default: 6
        int ejectFactor = defaultEjectFactor;
        double distX, distY, dist;

        for (int v = 0; v < mNodeList.size(); v++) {
            mDxMap.put(mNodeList.get(v).getIdentifier().toString(), 0.0);
            mDyMap.put(mNodeList.get(v).getIdentifier().toString(), 0.0);
            for (int u = 0; u < mNodeList.size(); u++) {
                if (u != v) {
                    distX = mNodeList.get(v).getX() - mNodeList.get(u).getX();
                    distY = mNodeList.get(v).getY() - mNodeList.get(u).getY();
                    dist = Math.sqrt(distX * distX + distY * distY);
                    if (dist < 30) {
                        ejectFactor = defaultSmallDistEjectFactor;
                    }
                    if (dist >= 0 && dist < 250) {
                        String id = mNodeList.get(v).getIdentifier().toString();
                        mDxMap.put(id, mDxMap.get(id) + distX / dist * k * k / dist * ejectFactor);
                        mDyMap.put(id, mDyMap.get(id) + distY / dist * k * k / dist * ejectFactor);
                    }
                }
            }
        }
    }

    /**
     * Calculate the traction force generated by the edge acted on the two nodes of its two ends.
     */
    private void calculateTraction() {
        int condenseFactor = defaultCondenseFactor;
        Node<T> startNode, endNode;
        for (Edge<T> edge : mEdgeList) {
            T eStartID = edge.getFirstNodeIdentifier();
            T eEndID = edge.getSecondNodeIdentifier();
            startNode = mNodeMap.get(eStartID.toString());
            endNode = mNodeMap.get(eEndID.toString());
            if (startNode == null) {
                throw new IllegalArgumentException("Missing start node for edge" + edge.getFirstNodeIdentifier().toString());
            }
            if (endNode == null) {
                throw new IllegalArgumentException("Missing destination node for edge" + edge.getSecondNodeIdentifier().toString());
            }
            double distX, distY, dist;
            distX = startNode.getX() - endNode.getX();
            distY = startNode.getY() - endNode.getY();
            dist = Math.sqrt(distX * distX + distY * distY);
            mDxMap.put(eStartID.toString(), mDxMap.get(eStartID.toString()) - distX * dist / k * condenseFactor);
            mDyMap.put(eStartID.toString(), mDyMap.get(eStartID.toString()) - distY * dist / k * condenseFactor);
            mDxMap.put(eEndID.toString(), mDxMap.get(eEndID.toString()) + distX * dist / k * condenseFactor);
            mDyMap.put(eEndID.toString(), mDyMap.get(eEndID.toString()) + distY * dist / k * condenseFactor);
        }
    }

    /**
     * update the coordinates.
     */
    private void updateCoordinates() {
        for (Node<T> node : mNodeList) {
            int dx = (int) Math.floor(mDxMap.get(node.getIdentifier().toString()));
            int dy = (int) Math.floor(mDyMap.get(node.getIdentifier().toString()));

            if (dx < -maxt) dx = -maxt;
            if (dx > maxt) dx = maxt;
            if (dy < -maxty) dy = -maxty;
            if (dy > maxty) dy = maxty;

            node.setX((node.getX() + dx) >= canvasWidth || (node.getX() + dx) <= 0 ? node.getX() - dx : node.getX() + dx);
            node.setY((node.getY() + dy) >= canvasHeight || (node.getY() + dy <= 0) ? node.getY() - dy : node.getY() + dy);
        }
    }
}

