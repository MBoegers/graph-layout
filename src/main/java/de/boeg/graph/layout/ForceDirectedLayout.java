package de.boeg.graph.layout;

import de.boeg.graph.layout.domain.Edge;
import de.boeg.graph.layout.domain.Node;

import java.util.*;

/**
 * Does the main magic for the force directed graph layout
 * derived from https://github.com/chaangliu/ForceDirectedLayout/blob/master/java/CollisionGenerator.java
 */
class ForceDirectedLayout<T> implements GraphLayout<T> {
    private final List<Node<T>> mNodeList = new ArrayList<>();
    private final List<Edge<T>> mEdgeList = new ArrayList<>();
    private final Map<T, Double> mDxMap = new HashMap<>();
    private final Map<T, Double> mDyMap = new HashMap<>();
    private final Map<T, Node<T>> mNodeMap = new HashMap<>();
    private final double k;

    private final int canvasHeight;
    private final int canvasWidth;
    private final int defaultEjectFactor;
    private final int defaultSmallDistEjectFactor;
    private final int defaultCondenseFactor;
    private final int maxDeltaX;
    private final int maxDeltaY;


    ForceDirectedLayout(List<Node<T>> nodeList,
                        List<Edge<T>> edgeList,
                        int height, int width,
                        int defaultEjectFactor, int defaultSmallDistEjectFactor,
                        int defaultCondenseFactor,
                        int maxDeltaX, int maxDeltaY) {
        /* save graph */
        this.mNodeList.addAll(nodeList);
        this.mEdgeList.addAll(edgeList);

        /* save configurations */
        canvasHeight = height;
        canvasWidth = width;
        this.defaultEjectFactor = defaultEjectFactor;
        this.defaultSmallDistEjectFactor = defaultSmallDistEjectFactor;
        this.defaultCondenseFactor = defaultCondenseFactor;
        this.maxDeltaX = maxDeltaX;
        this.maxDeltaY = maxDeltaY;

        /* setup */
        allToRandomPosition();

        k = Math.sqrt(canvasHeight * canvasWidth / (double) mNodeList.size());

        for (Node<T> n : nodeList) {
            mNodeMap.put(n.getIdentifier(), n);
        }
    }

    @Override
    public void layout() {
        calculateRepulsive();
        calculateTraction();
        updateCoordinates();
    }

    @Override
    public Collection<Node<T>> getNodes() {
        return this.mNodeList;
    }

    /**
     * change position of all nodes to a random one on the canvas
     */
    private void allToRandomPosition() {
        Random random = new Random(System.currentTimeMillis());
        for (Node node : mNodeList) {
            node.setX(random.nextDouble() * canvasWidth);
            node.setY(random.nextDouble() * canvasHeight);
        }
    }

    /**
     * Calculate the displacement generated by the repulsive force between two nodes.*
     */
    private void calculateRepulsive() {
        for (Node<T> v : mNodeList) {
            T identifier = v.getIdentifier();
            mDxMap.put(identifier, 0.0);
            mDyMap.put(identifier, 0.0);
            for (Node<T> u : mNodeList) {
               calculateRepulsiveFor(u,v, identifier);
            }
        }
    }

    /**
     * Calculate the delta x/y resulting from the two node and store them at the target position in the deltaMap
     * @param target node identifier to apply deltas to
     */
    private void calculateRepulsiveFor(Node<T> u, Node<T> v, T target) {
        if (u != v) {
            int ejectFactor = defaultEjectFactor;
            double distX = v.getX() - u.getX();
            double distY = v.getY() - u.getY();
            double dist = Math.sqrt(distX * distX + distY * distY);
            if (dist < 30) {
                ejectFactor = defaultSmallDistEjectFactor;
            }
            if (dist >= 0 && dist < 250) {
                mDxMap.put(target, mDxMap.get(target) + distX / dist * k * k / dist * ejectFactor);
                mDyMap.put(target, mDyMap.get(target) + distY / dist * k * k / dist * ejectFactor);
            }
        }
    }

    /**
     * Calculate the traction force generated by the edge acted on the two nodes of its two ends.
     */
    private void calculateTraction() {
        for (Edge<T> edge : mEdgeList) {
            T eStartID = edge.getFirstNodeIdentifier();
            T eEndID = edge.getSecondNodeIdentifier();
            Node<T> startNode = mNodeMap.get(eStartID);
            Node<T> endNode = mNodeMap.get(eEndID);
            if (startNode == null) {
                throw new IllegalArgumentException("Missing start node for edge" + edge.getFirstNodeIdentifier());
            }
            if (endNode == null) {
                throw new IllegalArgumentException("Missing destination node for edge" + edge.getSecondNodeIdentifier());
            }
            double distX = startNode.getX() - endNode.getX();
            double distY = startNode.getY() - endNode.getY();
            double dist = Math.sqrt(distX * distX + distY * distY);
            mDxMap.put(eStartID, mDxMap.get(eStartID) - distX * dist / k * defaultCondenseFactor);
            mDyMap.put(eStartID, mDyMap.get(eStartID) - distY * dist / k * defaultCondenseFactor);
            mDxMap.put(eEndID, mDxMap.get(eEndID) + distX * dist / k * defaultCondenseFactor);
            mDyMap.put(eEndID, mDyMap.get(eEndID) + distY * dist / k * defaultCondenseFactor);
        }
    }

    /**
     * update the coordinates.
     */
    private void updateCoordinates() {
        for (Node<T> node : mNodeList) {
            double nodeX = node.getX();
            double nodeY = node.getY();
            int dx = (int) Math.floor(mDxMap.get(node.getIdentifier()));
            int dy = (int) Math.floor(mDyMap.get(node.getIdentifier()));

            dx = Math.max(-maxDeltaX, Math.min(maxDeltaX, dx));
            dy = Math.max(-maxDeltaY, Math.min(maxDeltaY, dy));

            node.setX((nodeX + dx) >= canvasWidth || (nodeX + dx) <= 0 ? nodeX - dx : nodeX + dx);
            node.setY((nodeY + dy) >= canvasHeight || (nodeY + dy <= 0) ? nodeY - dy : nodeY + dy);
        }
    }
}

